package org.assistments.direct;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.assistments.connector.controller.AssignmentController;
import org.assistments.connector.controller.SchoolController;
import org.assistments.connector.controller.StudentClassController;
import org.assistments.connector.controller.UserController;
import org.assistments.connector.domain.StudentClass;
import org.assistments.connector.domain.User;
import org.assistments.connector.utility.Constants;
import org.assistments.connector.utility.Response;
import org.assistments.dao.controller.ExternalAssignmentDAO;
import org.assistments.dao.controller.ExternalStudentClassDAO;
import org.assistments.dao.controller.ExternalUserDAO;
import org.assistments.dao.domain.ExternalAssignment;
import org.assistments.dao.domain.ExternalStudentClass;
import org.assistments.dao.domain.ExternalUser;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class LiteUtility {

	public static String Direct_SCHOOL_REF = "070c9b2f-0ebe-46f0-a22e-e7d3d8a16ced";
	public static String PARTNER_REF = "Direct-Ref";
	public static String PARTNER_ID = "6";
	public static final String PASSWORD = "12345";
	public static String MARK = "Micro ASSISTments";
	static final String m_prefix = "PS";
    static final String m_version = "A";
    public static final String TIMEZONE = "GMT-4";
    public static final String REGISTRATION_CODE = "LAOLI";
    
	
	public static List<String> transferUser (User user, String thirdPartyID, String password) throws TransferUserException {
		List<String> result = new ArrayList<String>();

		String userRef = new String();
		String accessToken = new String();

		ExternalUserDAO userDAO = new ExternalUserDAO(PARTNER_REF);

		if (!userDAO.isUserExist(thirdPartyID)) {
			// teacher account doesn't exist, then create a new account for this
			// teacher
			ExternalUser externalUser = new ExternalUser(PARTNER_REF);
			externalUser.setPartner_external_reference(thirdPartyID);

			// create new User
			Response r = UserController.createUser(user, PARTNER_REF);
			if (r.getHttpCode() == 201) {
				JsonElement jElement = new JsonParser().parse(r.getContent());
				JsonObject jObject = jElement.getAsJsonObject();
				userRef = jObject.get("user").getAsString();
			} else {
				throw new TransferUserException(r.getContent());
			}

			externalUser.setExternal_refernce(userRef);

			accessToken = createAccessToken(userRef);

			externalUser.setUser_access_token(accessToken);
			try {
				externalUser.setUser_connector_token(getHash(password));
			} catch (Exception e) {
				e.printStackTrace();
				throw new TransferUserException(e.getMessage());
			}
			String school_ref = LiteUtility.Direct_SCHOOL_REF;
			SchoolController.assignUserToSchool(userRef, school_ref,
					LiteUtility.PARTNER_REF, accessToken);
			// update db
			userDAO.addNewUser(externalUser);
		} else {
			ExternalUser externalUser = userDAO.findByPartnerExternalRef(thirdPartyID);

			if (externalUser.getUser_access_token() == null
					|| externalUser.getUser_access_token() == "") {
				String tmp = createAccessToken(externalUser
						.getExternal_refernce());
				externalUser.setUser_access_token(tmp);
				externalUser.setNote("CreatedByConnector");
				userDAO.update(externalUser);
			}
			userRef = externalUser.getExternal_refernce();
			accessToken = externalUser.getUser_access_token();
		}
		result.add(userRef);
		result.add(accessToken);
		return result;
	}

	public static List<String> transferUser(User user) throws TransferUserException {
		List<String> result = new ArrayList<String>();

		String userRef = new String();
		String accessToken = new String();

		ExternalUserDAO userDAO = new ExternalUserDAO(PARTNER_REF);

		if (!userDAO.isUserExist(user.getEmail())) {
			// teacher account doesn't exist, then create a new account for this
			// teacher
			ExternalUser externalUser = new ExternalUser(PARTNER_REF);
			externalUser.setPartner_external_reference(user.getEmail());

			// create new User
			Response r = UserController.createUser(user, PARTNER_REF);
			if (r.getHttpCode() == 201) {
				JsonElement jElement = new JsonParser().parse(r.getContent());
				JsonObject jObject = jElement.getAsJsonObject();
				userRef = jObject.get("user").getAsString();
			}
			if (userRef == null || userRef.equals("")) {
				return null;
			}

			externalUser.setExternal_refernce(userRef);

			accessToken = createAccessToken(userRef);

			if (accessToken == null) {
				return null;
			}
			externalUser.setUser_access_token(accessToken);
			String school_ref = LiteUtility.Direct_SCHOOL_REF;
			SchoolController.assignUserToSchool(userRef, school_ref,
					LiteUtility.PARTNER_REF, accessToken);
			// update db
			userDAO.addNewUser(externalUser);
		} else {
			ExternalUser externalUser = userDAO.findByPartnerExternalRef(user
					.getEmail());

			if (externalUser.getUser_access_token() == null
					|| externalUser.getUser_access_token() == "") {
				String tmp = createAccessToken(externalUser	.getExternal_refernce());
				externalUser.setUser_access_token(tmp);
				externalUser.setNote("CreatedByConnector");
				userDAO.update(externalUser);
			}
			userRef = externalUser.getExternal_refernce();
			accessToken = externalUser.getUser_access_token();
		}
		result.add(userRef);
		result.add(accessToken);
		return result;
	}
	
	public static void directToErrorPage(String message, String instruction, HttpServletRequest req, HttpServletResponse resp) 
			throws ServletException, IOException {
		RequestDispatcher dispatcher = req.getRequestDispatcher("/error.jsp");
		req.setAttribute("error_message", message);
		req.setAttribute("instruction", instruction);
		dispatcher.forward(req, resp);
		return;
	}

	public static List<String> transferStudent(User student, String teacherRef) throws TransferUserException {
		List<String> result = new ArrayList<String>();

		String userRef = new String();
		String accessToken = new String();

		String partnerExternalRef = student.getDisplayName() +"_" +teacherRef;
		ExternalUserDAO userDAO = new ExternalUserDAO(PARTNER_REF);
		if (!userDAO.isUserExist(partnerExternalRef)) {
			// teacher account doesn't exist, then create a new account for this
			// teacher
			ExternalUser externalUser = new ExternalUser(PARTNER_REF);
			externalUser.setPartner_external_reference(partnerExternalRef);

			// create new User
			Response r = UserController.createUser(student, PARTNER_REF);
			if (r.getHttpCode() == 201) {
				JsonElement jElement = new JsonParser().parse(r.getContent());
				JsonObject jObject = jElement.getAsJsonObject();
				userRef = jObject.get("user").getAsString();
			}
			if (userRef == null || userRef.equals("")) {
				return null;
			}

			externalUser.setExternal_refernce(userRef);

			accessToken = createAccessToken(userRef);

			if (accessToken == null) {
				return null;
			}
			externalUser.setUser_access_token(accessToken);

			// update db
			userDAO.addNewUser(externalUser);
		} else {
			ExternalUser externalUser = userDAO
					.findByPartnerExternalRef(partnerExternalRef);

			if (externalUser.getUser_access_token() == null
					|| externalUser.getUser_access_token() == "") {
				String tmp = createAccessToken(externalUser
						.getExternal_refernce());
				externalUser.setExternal_refernce(tmp);
			}
			userRef = externalUser.getExternal_refernce();
			accessToken = externalUser.getUser_access_token();
			userDAO.update(externalUser);
		}
		result.add(userRef);
		result.add(accessToken);
		return result;
	}
	
	public static String createClass(String studentClassName,
			String accessToken, String studentClassPartnerRef) {
		ExternalStudentClass studentClass = new ExternalStudentClass(PARTNER_REF);
		ExternalStudentClassDAO studentClassDAO = new ExternalStudentClassDAO(
				PARTNER_REF);
		String classRef;
		if (!studentClassDAO.isClassExist(studentClassPartnerRef)) {
			StudentClass assisTmentsClass = new StudentClass(studentClassName);
			Response r = StudentClassController.createStudentClass(
					assisTmentsClass, PARTNER_REF, accessToken);

			if (r.getHttpCode() == 201) {
				classRef = parseClassJson(r.getContent());
			} else {
				return null;
			}
			studentClass.setExternal_refernce(classRef);
			studentClass.setUser_access_token(accessToken);
			studentClass.setPartner_external_reference(studentClassPartnerRef);
//			studentClass.setUser_access_token(MARK);
			studentClassDAO.addNewClass(studentClass);
			return classRef;
		} else {
			studentClass = studentClassDAO
					.findByPartnerExternalRef(studentClassPartnerRef);
			return studentClass.getExternal_refernce();
		}
	}
	
	public static String createAssignment(String problemSetID, 
			String studentClassRef, String accessToken, String thirdPartyID) {
		ExternalAssignmentDAO assignmentDAO = new ExternalAssignmentDAO(
				PARTNER_REF);
		String partnerExternalRef = thirdPartyID;
		// if (!assignmentDAO.isAssignmentExist(partnerExternalRef)) {
		ExternalAssignment assignment = new ExternalAssignment(PARTNER_REF);
//		assignment.setExternal_refernce(partnerExternalRef);
//		assignment.setUser_connector_token(MARK);
		String assignmentRef = "";
		Response r = AssignmentController.createAssignment(problemSetID,
				studentClassRef, LiteUtility.PARTNER_REF, accessToken);
		if (r.getHttpCode() == 201) {
			assignmentRef = parseAssignmentJson(r.getContent());
			assignment.setExternal_refernce(assignmentRef);
			assignment.setUser_access_token(accessToken);
			assignment.setPartner_external_reference(partnerExternalRef);
			assignment.setNote(studentClassRef);
			assignmentDAO.addNewAssignment(assignment);
			return assignmentRef;
		} else {
			return null;
		}
	}

	public static String createAssignment(String problemSetID,
			String studentClassRef, String accessToken) {
		ExternalAssignmentDAO assignmentDAO = new ExternalAssignmentDAO(
				PARTNER_REF);
		String partnerExternalRef = studentClassRef;
		// if (!assignmentDAO.isAssignmentExist(partnerExternalRef)) {
		ExternalAssignment assignment = new ExternalAssignment(PARTNER_REF);
		assignment.setExternal_refernce(partnerExternalRef);
//		assignment.setUser_connector_token(MARK);
		String assignmentRef = "";
		Response r = AssignmentController.createAssignment(problemSetID,
				studentClassRef, PARTNER_REF, accessToken);
		if (r.getHttpCode() == 201) {
			assignmentRef = parseAssignmentJson(r.getContent());
			assignment.setExternal_refernce(assignmentRef);
			assignment.setUser_access_token(accessToken);
			assignment.setPartner_external_reference(partnerExternalRef);
			assignmentDAO.addNewAssignment(assignment);
			return assignmentRef;
		} else {
			return null;
		}
	}

	public static User populateStudentInfo(String firstName, String lastName) {
		User student = new User();

		student.setUserType(Constants.PROXY);
		student.setPassword(PASSWORD);
		student.setFirstName(firstName);
		student.setLastName(lastName);
		// user.setEmail(ltiUser.getEmail());
		Long time = uniqueCurrentTimeMS();
		String fakeEmail = time.toString();
		student.setEmail(fakeEmail);
		student.setUsername(fakeEmail);
		student.setDisplayName(firstName + " " + lastName);
		student.setTimeZone(TIMEZONE);
		student.setRegistrationCode(REGISTRATION_CODE);
		return student;
	}

	public static User populateTeacherInfo(String firstName, String lastName,
			String displayName) {
		User user = new User();
		user.setUserType(Constants.PRINCIPAL);
		user.setPassword(LiteUtility.PASSWORD);
		user.setFirstName(firstName);
		user.setLastName(lastName);
		user.setDisplayName(displayName);

		Long  time = uniqueCurrentTimeMS();
		String fakeEmail = time.toString() + "@als.com";
		user.setEmail(fakeEmail);
		user.setUsername(time.toString());
		user.setTimeZone(TIMEZONE);
		user.setRegistrationCode(REGISTRATION_CODE);
		return user;
	}
	
	/**
	 * Create access token inside ASSISTments for this user based on user external reference
	 * Before calling this function, make sure the user does not have access token
	 * @param userRef -- use external reference inside ASSISTments
	 * @return access  token inside ASSSISTments
	 */
	public static String createAccessToken(String userRef) throws TransferUserException {
		String accessToken= "";
//			ASSISTmentsRequest assistmentsRequest = new ASSISTmentsRequest();
//			assist_access_token = assistmentsRequest.createAccessToken(userRef);
		Response r = UserController.createAccessToken(userRef, LiteUtility.PARTNER_REF);
		if(r.getHttpCode() < 400) {
			JsonElement jElement = new JsonParser().parse(r.getContent());
			JsonObject jObject = jElement.getAsJsonObject();
			accessToken = jObject.get("access").getAsString();
		} else {
			throw new TransferUserException(r.getContent());
		}
		return accessToken;
	}
	
	public static String encodeProblemSetId(int psId) {
        if (psId == 0)
            return "";
        
        String code = "abcdefghjkmnpqrstuvwxyz23456789";
        String prefix = "PS";
        String version = "A";                
        int index = psId;
        StringBuffer encodeId = new StringBuffer();        
        if (version.equals("A")) {
            while (index > 0) {
                char c = code.charAt(index % code.length());
                index /= code.length();
                encodeId.append(c);
            }
        }
        return prefix + version + encodeId.reverse().toString().toUpperCase();
    }

	/**
	 * Convert encoded problem set string to problem set id
	 * @param psString -- encoded problem set string (PSxxxx)
	 * @return problem set number id (a String)
	 */
	public static String decodeProblemSetString(String psString) {
        if (psString.isEmpty()) {
            return null;
        }
        
        // decode prefix
        if (!psString.substring(0, m_prefix.length()).equalsIgnoreCase(m_prefix)) {
            return null;
        }
        
        // decode version
        if (!psString.substring(m_prefix.length(), m_prefix.length() + m_version.length()).equalsIgnoreCase(m_version)) {
            return null;
        }
        
        // decode problem id
        String code = "abcdefghjkmnpqrstuvwxyz23456789";
        int decodedId = 0;
        String psStringLowerCase = psString.toLowerCase();
        for (int i = m_prefix.length() + m_version.length(); i < psStringLowerCase.length(); i++) {
            char c = psStringLowerCase.charAt(i);
            int oldValue = decodedId;
            decodedId = decodedId * code.length() + code.indexOf(c);
            if (decodedId < oldValue) {
                throw new RuntimeException("Overflow decoded id");
            }
        }
        return new Integer(decodedId).toString();
    }

	private static String parseClassJson(String classRefJson) {
		JsonElement jEelement = new JsonParser().parse(classRefJson);
		JsonObject jObject = jEelement.getAsJsonObject();
		String classRef = jObject.get("class").toString(); // "d15daef3972c4a7528afd6f97e9f536a"
		classRef = classRef.substring(1, classRef.length() - 1);
		return classRef;

	}

	private static String parseAssignmentJson(String assingmentRef) {
		JsonElement jEelement = new JsonParser().parse(assingmentRef);
		JsonObject jObject = jEelement.getAsJsonObject();
		String assignmentRef = jObject.get("assignment").toString(); // "d15daef3972c4a7528afd6f97e9f536a"
		assignmentRef = assignmentRef.substring(1, assignmentRef.length() - 1);
		return assignmentRef;

	}
	private static final AtomicLong LAST_TIME_MS = new AtomicLong();
	public static long uniqueCurrentTimeMS() {
	    long now = System.currentTimeMillis();
	    while(true) {
	        long lastTime = LAST_TIME_MS.get();
	        if (lastTime >= now)
	            now = lastTime+1;
	        if (LAST_TIME_MS.compareAndSet(lastTime, now))
	            return now;
	    }
	}
	public static String getHash(String password)  {
		String generatedPassword = null;
        try {
            // Create MessageDigest instance for MD5
            MessageDigest md = MessageDigest.getInstance("MD5");
            //Add password bytes to digest
            md.update(password.getBytes());
            //Get the hash's bytes
            byte[] bytes = md.digest();
            //This bytes[] has bytes in decimal format;
            //Convert it to hexadecimal format
            StringBuilder sb = new StringBuilder();
            for(int i=0; i< bytes.length ;i++)
            {
                sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
            }
            //Get complete hashed password in hex format
            generatedPassword = sb.toString();
        }
        catch (NoSuchAlgorithmException e)
        {
            e.printStackTrace();
        }
        return generatedPassword;
	 }
}
